# HTTP 와 HTTPS 차이

### 1. HTTP

- Hypertext Transfer Protocol
- 인터넷에서 데이터를 주고받을 수 있는 통신 규약
- 웹상에서 클라이언트와 서버 간 통신(데이터 전송)을 위한 프로토콜
- 클라이언트가 서버에 요청을 하고 서버가 클라이언트에게 응답을 보내면 통신을 끊고 상태 정보(ex 로그인)를 유지하지 않는다.
- HTTP 프로토콜을 사용하면서 Server가 Client를 식별할 수 있는 방법이 필요했고 쿠키와 세션을 사용하게 되었다.
- 쿠키와 세션을 사용하지 않으면 게시판이나 메일을 확인할 때 페이지를 이동할 때마다 로그인 해야 한다.

단점 :

- HTTP는 서버에서 브라우저로 전송되는 정보가 암호화되지 않는 문제점
- 암호화되지 않은 방법으로 데이터를 전송한다. (악의적인 감청, 데이터 변조의 가능성)
- 데이터가 쉽게 도난당할 수 있는 가능성 존재

HTTP 헤더 :

- 헤더는 변경 가능하기 때문에 무조건 신뢰하는 것은 X

> 1 . 공통 헤더 : 요청 & 응답에 모두 사용되는 헤더

```
1) Date : HTTP 메시지가 만들어진 시각 , 자동 생성
2) Connection
3) Content-Length : 요청과 응답 메시지의 본문 크기를 바이트 단위로 표시, 메시지 크기에 따라 자동 생성
4) Cache-Control
5) Content-Type : 컨텐츠의 타입(MIME)과 문자열 인코딩(utf-8 등등)을 명시
    ex) Content-Type: text/html; charset=utf-8
    = 현재 메시지 내용이 text/html 타입이고 문자열은 utf-8 문자열
6) Content-Language : 사용자 언어
7) Content-Encoding
```

> 2 . 요청 헤더 : 요청 & 응답에 모두 사용되는 헤더

```
1) HOST : 서버 도메인 네임
2) User-Agent : 클라이언트 요청 디바이스 환경
3) Accept : 클라이언트가 허용할 수 있는 파일 형식
4) Cookie : 저장된 클라이언트 쿠키 정보를 이름-값 쌍으로 웹서버에 전송
5) Origin : 요청이 시작된 주소 확인
6) If-Modified-Since :
7) Authorization : 인증 토큰을 서버로 보낼 때 사용
```

> 3 . 응답 헤더 : 요청 & 응답에 모두 사용되는 헤더

```
1) Server : 웹 서버 정보
2) Access-Control-Allow-Origin : 서버에서 이 헤더에 헤더에 프론트 주소를 적어주면 응답 메시지에 CORS 에러가 발생하지 않는다
3) Allow : 클라이언트가 허용할 수 있는 파일 형식
4) Content-Disposition : 응답 본문을 브라우저가 어떻게 표시해야 할지 알려주는 헤더
5) Location : 300번대 응답이나 201 Created 응답일 때 어느 페이지로 이동할지를 알려주는 헤더
6) Content-Security-Policy : 외부 파일들을 불러오는 경우, 차단할 소스와 불러올 소스를 여기에 명시 가능
7) Authorization : 인증 토큰을 서버로 보낼 때 사용
```

### 2. HTTPS

- HTTP에 SSL을 사용한 프로토콜
- HTTP를 안전하게 만드는 방식
- HTTP에서 전송되는 정보가 암호화되지 않는 문제점 해결
- HTTPS는 HTTP 자체(Header)를 암호화하는 것은 X
- HTTP를 사용해 운반하는 내용, 즉 HTTP Message Body를 암호화하는 것
- HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화
- HTTPS는 TCP위에 놓인 보안계층(SSL)위의 HTTP이다
- HTTP의 하부에 SSL과 같은 보안계층을 제공함으로써 동작

<br/>

# HTTP가 아닌 HTTPS를 사용해야 하는 이유

1. 보안성 확보

```
HTTP로 데이터 전송 시 네트워크로 데이터 원본 자체가 전달되어 데이터 내용을 바로 탈취할 수 있다.
HTTPS의 경우 전송할 데이터를 암호화하여 전달하여 암호화된 내용을 알기 어렵다.
```

2. 검색 엔진 최적화

```
구글은 HTTPS 웹 사이트에 가산점 부여되어 검색 엔진에 빈번히 노출될 수 있다.
```

3. 모바일 친화적 사이트

```
모바일 친화적인 웹사이트 + 검색 순위 증가 시키는게 중요한 요즘
AMP(가속화된 모바일 페이지) & PWA 제작시 HTTPS 사용은 필수적이다.
* AMP * : 구글이 제작한 모바일 기기에서 컨텐츠 훨씬 빠르게 로딩하기 위한 방법
```

<!-- ### 1. 데이터 전송 시 보안성 확보

- HTTP로 데이터를 전송하는 경우

  - 네트워크로 전달되는 데이터는 원본 그 자체
  - 해커가 중간에서 가로챈 후 해당 데이터 내용을 바로 확인 가능

- HTTPS의 경우
  - HTTP와 달리 데이터를 암호화하여 전송
  - 해커가 중간에서 데이터를 가로채도 데이터는 암호화 되어 있기 때문에 어떤 내용을 가지고 있는지는 알기 어렵다

<br/>

### 2. 검색 엔진 최적화

- 구글은 HTTPS를 사용하는 웹 사이트에 가산점 부여
- 웹 사이트가 검색 엔진에 더 빈번하게 노출되고 싶다면, HTTPS는 불가피한 선택
- AMP를 만들 때 HTTPS 사용해야만 한다.

  ```
  AMP (가속화된 모바일 페이지)
  모바일 기기에서 컨텐츠를 훨씬 빠르게 로딩하기 위한 방법으로 구글에서 만들어졌다.
  ```

- 모바일 친화적인 웹 사이트를 만들고, 모바일 검색 순위를 증가시키는 게 점점 더 중요해졌기 때문에 HTTPS로 전환하는 것은 필수적 -->

<br/>

# SSL (Secure Sockets Layer)

- 보안 소켓 계층
- HTTP 자체가 아닌 운반하는 메시지 body 부분만 암호화한다.
- Netscape사에서 웹 서버와 웹 브라우저간의 보안을 위해 만든 프로토콜
- 서버와 브라우저 사이에 안전하게 암호화된 연결이 가능하도록 돕는다.
- SSL 인증서 무료 발급 : `Let’s Encrypt`와 `AWS Certificate Manager`
- SSL은 사이트 외에 인증기관과 사용자도 협력하기 때문에 안전한 접속 방법
- 사용자가 접속하는 사이트가 믿을 수 있는 사이트인지 확인이 가능해 진다.
- 각 방식이 가진 단점 때문에 공개키 방식과 대칭키 방식을 혼합해서 사용 = 공개키 방식으로 대칭키를 전달
  ```
  대칭키 방식 : 동일한 키로 암호&복호화 수행 / 누구든 키를 가지고 있다면 데이터를 쉽게 복호화 가능
  공개키 방식 : 암호(공개키)&복호화(개인키) 수행 / 암호화 연산 비용이 더 크다
  ```
- SSL의 업그레이드 버전은 TLS이며 일반적으로 두단어를 동일한 의미로 사용한다.

### SSL 필요한 이유 ( = 보안 )

- 서버와 브라우저간 전송되는 데이터를 외부의 공격자로부터 보호하기 위해
- 암호화의 대상은 내용이 유출됐을 때 자칫 악용되어 사용될 수 있는 비밀번호나 개인 정보 등이 해당

### SSL 통신 과정

- SSL은 공개키 방식으로 대칭키를 전달
- 대칭키를 활용해서 암호화와 복호화를 하고, 서버와 브라우저간 통신을 진행

1. 접속 요청
2. 접속 받은 측은 자신의 공개키를 전송
3. 접속 대상은 자신의 대칭키를 전달받은 공개키로 암호화하여 요청 대상에게 전달
4. 상대측은 대칭키를 자신의 개인키로 복호화 결과 대칭키를 얻어낸다.
5. 얻어낸 대칭키를 활용해 안전하게 통신합니다.
   -> 데이터 암호화와 복호화를 위한 한 쪽의 대칭키를 다른 쪽의 공개키로 암호화하여 전송하면, 반대편에서 자신의 개인 키로 복호화하여 그 반대편의 대칭키를 알아내고 그 대칭키를 바탕으로 서로 통신을 하게 됩니다.

- 사용자가 접속한 사이트가 유효한 사이트인지 확인 방법 with 제 3의 인증 기관

[사용자가 사이트 접속 전]

1. 사이트에서 인증기관에게 사이트 정보와 사이트 공개키 전달
2. 인증기관에서 사이트 인증서 발급 전, 전달받은 데이터를 검증
3. 인증기관은 사이트 인증서를 생성하기 위해 해당 데이터를 자신의 개인키로 서명합니다
4. 생성된 인증서를 사이트에게 전달
5. 인증기관은 사용자에게 자신의 공개키를 전달
6. 사용자가 인증기관으로부터 전달받은 인증기관 공개키는 사용자의 브라우저에 자동으로 내장된다.

[사용자가 사이트 접속 후]

1. 사용자가 사이트에 접속을 요청합니다
2. 사이트는 신뢰할 수 있는 사이트임을 증명하기 위해 사용자에게 자신의 인증서 전달
3. 사용자는 브라우저에 내장되어 있는 인증기관 공개키로 사이트 인증서를 복호화하여 검증
4. 사이트 인증서를 해독하면, 사이트 정보와 사이트 공개키를 얻을 수 있다.
5. 얻은 사이트 공개키로, 사용자는 암호화한 자신의 대칭키를 사이트에게 전달한다.
6. 사이트는 사용자로부터 전달받은 암호문을 자신의 개인키로 해독하여 사용자의 대칭키를 얻습니다.
7. 얻은 대칭키를 활용하여 사용자와 사이트는 암호문을 주고받을 수 있게 된다 = SSL 통신을 하게 된다.

  <br/>
# TLS (Transport Layer Security \_ 전송 계층 보안)

- 응용 & 전송계층 사이에 위치하여 정보의 안전한 통신을 책임져주는 프로토콜
- 무결성 보장을 위해 TSL는 메시지 인증 코드, 키 자료 생성 등을 사용하여 상대측의 신원 확인 및 메시지 무결성 보장
- SSL를 개선하여 더 안전하고 효율적으로 개인 정보 보호, 무결성 및 데이터 보호 기능을 제공

  <br/>

> 기능

1. 암호화 : 제 3자가 전송 데이터에 액세스하지 못하도록 데이터를 암호화
2. 인증 : 메시지 발신자의 신원 확인 기능

   - https 사이트의 자물쇠 아이콘은 자신이 접속한 사이트의 호스트가 누구인지 신원을 증명하는 인증서 확인이 가능

3. 무결성

   - 발신측에서 메시지와 함께 메시지인증코드(MAC) 암호화한 다음 수신자에게 전송
   - 수신측에서 메시지 받고 자신이 받은 메시지와 MAC이 일치여부 확인

  <br/>

> 통신 과정

1. 클라이언트측이 응용계층에서 http 메시지를 만들어 하위 계층으로 전달한다.
2. TLS가 중간에서 메시지 암호화하여 전송계층으로 전달돼 목적지까지 전달된다.
3. 수신 측에선 데이터를 다시 TLS가 복호화한 다음 응용 계층으로 올려주면서 원본 메세지를 확인할 수 있다.
