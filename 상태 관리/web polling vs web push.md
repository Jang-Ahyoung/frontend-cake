# 실시간 웹 (Realtime Web)

사용자가 업데이트 된 정보를 즉시 수신할 수 있도록 하는 기술

```
요청이 있을 때마다 페이지를 새로 그리는 포스트 백를 해결하고자 Ajax가 등장하면서
사용자 인터페이스의 나머지 부분을 방해받지 않고 비동기로 데이터 송/수신하여 전체 페이지 로드 없이 변경 사항이 존재하는 일부에만 반영되 빠른 화면 전환이 가능해져 사용자 경험이 증가
```

> Realtime web을 구현하기 위한 기술

    대부분 Ajax 기반 기술 + 프로토콜 사용한 웹 소켓

- web polling : 전송할 데이터 유무에 관계없이 주기적으로 요청 수행하는 방법
- long-polling
- web push : 요청없이 서버에서 클라이언트로 정보를 전달
- SSE (Server-sent events)
- Websocket

<br/>

<!--


- 정적 웹페이지 : 미리 저장된 파일 그대로 전달
- 동적 웹페이지 : 사용자 요청 해석하여 동적으로 생성된 파일 전달
- 실시간 웹 : 페이지의 현재 상태를 방해하지 않고 서버와 통신 -->

# Polling (폴링)

```
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms))
```

- 데이터 유무에 관계없이 주기적으로 서버에 요청해 정보를 전달받는 방식
- 충돌 회피 / 동기화 처리 등을 목적으로 상태를 주기적으로 검사해 조건 만족시 자료처리 하는 방식

  > 단점

  - 불필요한 네트워크 비용 발생
  <!-- - 서버로 불필요한 요청 & 응답이 많이 발생해 부담이 생길 수 있음(실시간 요청처럼 보이게 하기 위해선) -->
  - 요청 간격 길어지면 다음주기까지 데이터가 실시간으로 반영이 되지 않아 실시간성 떨어지고
  - 요청 간격이 짧다면 클라이언트와 서버 자원이 많이 낭비된다 <br/><br/>
  - 모두 HTTP를 통해 통신하기 때문에 빠르게 데이터를 주고 받기에는 요청, 응답 Header가 불필요하게 크다

  > 장점

  - 서버 이벤트가 일정한 주기로 발생하면 효율적
  - 주기적으로 요청하기 때문에 사용자들이 많아도 서로 다른 주기나 시간에 요청 진행 가능<br/><br/>

  > 활용

  - 실시간 메시지 전달이 크게 중요하지 않은 서비스
  - 서버 개발할 수 없거나 외부 API가 서버 푸시를 지원하지 않는 상황<br/><br/>

# Long polling (폴링)

- 클라이언트 요청에 대해 서버가 가지고 있다 이벤트 발생 시 응답을 통해 정보 전달받는 방식
- 클라이언트 요청을 서버가 전송할 데이터가 있거나 타임아웃될 때까지 연결을 유지한다.
- 타임아웃 시 이벤트가 없으면 응답없는 타임 아웃 이벤트 전송
- 서버로부터 응답 받는 즉시 롱 폴링 요청을 다시 수행한다<br/><br/>

  > 장점

  - 불필요한 네트워크 비용 감소 (polling 방식에 비해 불필요한 요청 & 응담을 덜 발생시킴)
  - 서버 이벤트 발생 즉시 응답하기 때문에 실시간성이 높다.<br/><br/>

  > 단점

  - 서버 이벤트가 빈번하게 발생한다면 폴링보다 더 많은 요청을 수행하게 된다.
  - 응답 받는 즉시 모든 클라이언트가 다시 요청하기 때문에 사용자 수가 너무 많다면 셀프 디도스 공격과도 같다.<br/><br/>

  > 활용

  - 실시간 메시지 전달이 중요한 서비스

<br/>

# SSE (Server-sent events = http 스트리밍 방식)

```
const subscribe = () =>{
  const subscriber = new EventSource('/api/posts/subscribe')
  subscriber.onmessage = (e) => {
    prependPosts(JSON.parse(e.data))
  }
}
fetchPosts(0).then(subscribe)
```

- HTTP 연결을 통해 서버에서 클라이언트로 데이터 수신을 가능하게 함
- HTTP 사용해 서버 푸시를 구현하는 방법
- 클라이언트 요청에 대해 서버는 무기한 연결을 유지하고 데이터 준비되면 전송하는 방식
- 서버 이벤트가 발생에 대한 응답 후 연결을 끊지 않고 응답 스트림에 청크 단위의 데이터를 계속 전송하여 쌓이도록 한다<br/><br/>

> 장점

- 기존 HTTP 사용해 개발 방식이 다르지 않다
- 한 번의 요청과 응답에 대해 HTTP 헤더가 한번 발생하고, 나머지는 청크 단위로 데이터를 보내기 때문에 헤더로 인한 오버헤드가 거의 없다
- 연결이 유지되기 때문에 실시간성이 매우 높다
- 연결이 끊긴 경우 자동으로 재접속 처리 진행 ( 자동 재연결 )<br/><br/>

> 단점

- 연결된 상태를 유지 & 서버가 일방적으로 데이터 전송 (단방향)
- 사용자는 메시지 구독 과정이 필요
- 서버에서 클라이언트로 단방향 통신만 가능하다<br/><br/>

> 활용

- 새로운 데이터 즉시 수신만 해도 되는 경우(알림, 실시간 댓글 등 구현)<br/><br/>

# 웹소켓

- TCP 연결을 통해 실시간 양방향 통신 지원
- 연결된 통로로 메시지를 양방향으로 주고받을 수 있는 기술
- HTTP(80) or HTTPS(443)를 통해 웹소켓 프로토콜로 전환하는 handshake 과정이 필요

<!-- - HTTP 아닌 웹 소켓 사용해 실시간 양방향 통신 지원하는 방법 -->
<!-- - 웹소켓을 통해 통신이 이루어져 http 한계 뛰어넘을 수 있다 -->

> 과정

```
클라이언트가 서버로 헤더의 upgrade 속성을 사용해 + Connection : Upgrade (Connection 헤더 필드를 Upgrade 옵션으로 지정)를 명시하여 요청을 보내면 서버가 웹소켓 지원할 경우 HTTP에서 다른 프로토콜인 ws(wss, 웹소켓)으로 전환된다
```

1. 클라이언트는 http를 사용해 handshake 요청

   - 연결 수립 과정은 HTTP 프로토콜 사용 & 버전 1.1 이상이여야되고 & GET 메소드 사용해 요청해야한다

2. 서버에서 처리 후 http을 통해 handshake 과정을 완료(101 응답 : Switching Protocol 과정)
3. 클라이언트와 서버가 이어져 웹 소켓 사용한 통신이 가능해진다 <br/><br/>

> 장점

- 클라이언트가 데이터를 전송해서 서버는 응답해주지 않아도돼
- HTTP를 사용하지 않아 전체 메시지 크기 줄어든다
- 클라이언트 & 서버 자원 최소화할 수 있다
- 양방향으로 빠른 요청과 응답이 가능하다<br/><br/>

> 활용

- 네트워크 지연 최소화해야 될 경우
- 사용자 간 빠른 피드백이 이루어져야 할 경우 (채팅, 게임 등)
