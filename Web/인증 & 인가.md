# 인증과 인가

- 인증 : 서비스에 등록된 유저의 신원을 입증하는 과정 (Authentication)
- 인가 : 인증된 사용자에 대한 자원 접근 권한 입증하는 과정

> 웹에서의 인증/인가

- http와 실제 인증-인가 구현 할 때의 두 상태성이 충돌
- 유저의 상태 어디에 저장할 것인가에 대한 `보안`과 `사용자의 편의성`에 대한 밸런스가 중요

  ```
  사용자에게 로그인 성공할 수 있도록 인증 수행 (클라이언트가 사용자 정보 관리하도록)
  브라우저 힘을 빌려서 로그인 지속 (쿠키 도입)
  보안상 문제가 생겨 서버까지 와서 인증 인가 (세션)
  서버 여러 대일 경우 로드밸런서 문제 떄문에 별도 세선스토리지 도입
  ```

- 요청 헤더 : Request Header 통해 로그인 (= 인증하기)
- 세션, 쿠키 : Browser를 통해 인증 유지 & 서버를 통해 안정하게 인증 수행
- 토큰 (JWT) : 토큰 활용해 효율적으로 인증
- OAuth : 다른 채널 통해 인증하는 개념

<br/>

# 브라우저 처리 과정

> 인증 과정

1. URL에서 아이디 & 비밀번호 파싱하여 인코더(Base64)를 통해 인코딩
2. 인코딩된 문자열을 요청 헤더 Authorization에 넣어 HTTP 전송
3. 전달된 서버가 DB 체킹을 통해 DB에 실제로 값이 있다면 로그인 처리

<br/>

> 문제점 : 사용자가 매번 로그인을 통해 인증 수행하는 번거로움

    - 리소스 절약을 위해 Server가 Client를 식별할 수 있는 방법이 필요

> 해결 : 브라우저 storage 활용

- 로컬 & 세션스토리지 & 쿠키

<br/>

# 쿠키

- 사용자가 인증이 필요한 요청 시 함께 전송되어 원하는 자원 받을 수 있어 편리

<br/>

> 인증 과정

1. 로그인시 서버는 사용자 정보를 저장하고, 열쇠로 사용할 수 있는 세션 ID 생성(세션 사용 시)
2. 서버에서 HTTP Response Header의 Set-Cookie 속성을 이용하여 클라이언트 쿠키 생성
3. HTTP 헤더에 실어 클라이언트에게 전송 & 클라이언트측은 해당 쿠키를 저장
4. 인증 필요한 http 요청 시 Headers에 실려서 서버로 전송
   - 같은 도메인에서 만들어진 쿠키만 전송 가능

<br/>

> 특징 :

- 브라우저에 메모리 or 파일에 저장되는 작은 크기의 문자열
- 최대 4KB 까지 저장 가능
- 저장 정보 : 이름, 값, 만료 날짜/시간(쿠키 저장기간), 경로 정보 등 + <b>세션 ID</b>
- Expires 또는 Max-Age를 통해 만료기간 설정 가능

  - Expires & Max-Age 둘 다 존재시 Expires는 무시 된다

- 고유한 ID 값 발급받아 회원정보를 확인할 필요 없이 바로 어떤 회원인지를 확인할 수 있어 서버의 자원에 접근하기 용이
- 쿠키가 담긴 HTTP 요청이 도중에 노출되더라도 중요한 정보는 서버 세션에 존재하고 쿠키 자체(세션 ID)는 유의미한 값을 갖고 있지 않게 한다.

<br/>

> 종류

1. 라이프 사이클(만료 기간)에 따라 영구 & 세션 쿠키

- 영구 쿠키 : 만료 기간을 정한 쿠키 \_ 브라우저를 종료해도 만료 기간이 끝나지 않으면 삭제되지 X
  - 파일로 저장되어 비교적 보안에 취약
- 세션 쿠키 : 만료 기간을 정하지 않은 쿠키 \_ 브라우저 종료 시 삭제
  - 안전한 브라우저(ex. 구글 크롬)의 메모리에 저장
    <br/>

2. 퍼스트 & 서드파티 쿠키 <br/>

- 퍼스트파티 쿠키 : 같은 도메인에서 생성된 쿠키 (서브도메인 경우도 포함)
- 서드파티 쿠키 : 다른 도메인에서 생성된 쿠키

  - 타 도메인의 스크립트가 존재할 때 생성
  - 스크립트뿐만 아니라 이미지, 폰트, 아이프레임 등 다른 도메인으로 요청을 해야 하는 경우에 추가적으로 서드파티 쿠키 언제든지 생성 가능<br/>

  예시 ) `https://front.kr` 의 경우<br/>
  front.kr : 같은 도메인 <br/>
  m.front.kr : 서브 도메인 = 퍼스트파티 쿠키 <br/>
  back.com : 다른도메인 = 서드파티 쿠키 <br/><br/>

> 문제점 : 보안적 취약점 (CSRF, XSS에 노출)

- 스토리지에 사용자의 정보가 그대로 노출되어 해커 입장에서도 편리

  - `CSRF` : 쿠키가 자동으로 전송되는 특징을 이용해서 사이트에 로그인이 되어 있는 사용자에게 악성 스크립트를 실행시켜 비밀번호를 변경하거나 결제 요청 같은 악의적인 요청을 하는 것
  - `XSS` : 악성 스크립트를 실행시켜서 사용자의 토큰과 같은 민감한 정보를 탈취하는 것 (Reflected, Stored, DOM-based로 세 가지 종류)

- 클라이언트는 상대적으로 서버에 비해 보안에 취약하다는 단점
- http 요청 시 항상 자동으로 모든 쿠키를 전송해 불필요한 트래픽을 증가

> 해결 : 서버 활용 \_ 자원을 바로 클라이언트로로 보내지 않고 Session 개념 도입

<br/>

# 웹 스토리지

- 쿠키의 문제점을 어느 정도 해결하기 위해 html5에 등장
- 동기적으로 실행된다

> 종류

1. <b>로컬 스토리지</b>

- 도메인별, 브라우저별로 독립된 스토리지 사용
- 만료 기간 X -> 브라우저 종료해도 삭제되지 X, 직접 삭제 시 삭제된다

2. <b>세션 스토리지</b>

- 탭 별로 독립된 스토리지 사용
- 탭만 바뀌어도 세션 스토리지가 동일하지 X
- 탭 종료 or 브라우저 종료하면 삭제된다

<br/>

> 장점

- 요청시 Headers에 전송 X, 자동으로 전송되지 X
  - 쿠키의 CSRF 보안 문제, 트래픽 문제 해결

> 고려 사항

- 대부분의 브라우저는 웹 스토리지를 지원하지만 버전에 따라 웹 스토리지를 지원하지 않을 수도 있다
- 웹 스토리지를 지원한다고 해도 웹 스토리지를 비활성화 할 수 있는 기능을 제공하는 브라우저도 존재하기 때문에 에러가 발생 가능성 존재

  - Ex) 사파리 브라우저

  ```
  시크릿 모드로 접속시 스토리지 할당량이 0으로 설정되어 할당량 초과 에러 발생
  즉, 웹스토리지 를 사용할 때는 반드시 에러처리를 해야 한다.
  ```

- 웹 스토리지는 문자열만 저장이 가능
  - 객체를 저장 & 사용하기 위해 직렬화 과정 필요
    - `JSON.stringify()` & `JSON.parse()`
  - 직렬화 시 순환 참조이거나, 역직렬화 할 때 JSON 형식이 아닌 경우 에러 발생

<br/>

> 문제점

- 마찬가지로 XSS에 취약
- 브라우저간 공유가 되지 않아 서로 다른 브라우저(데스크탑/모바일)로 접속 시 다른 데이터를 볼 수 있다
- 시간 설정 불가
- 동기적으로 실행 되기 때문에 메인 스레드를 블록킹하게 된다.
  - 따라서 큰 데이터를 다루는 것을 주의해야
  - 용량이 큰 경우 IndexedDB를 고려해 볼 필요가 있다

<br/>

# 쿠키 & 웹 스토리지

- 사용 : 보안 문제가 있기 때문에 민감한 정보는 저장하지 않는 것이 바람직
- 쿠키나 웹 스토리지를 사용할 때는 각각의 특징을 잘 파악하여 프로젝트 성격에 맞게 사용하는 것이 중요

> 쿠키

    기간을 설정해야 하거나 자동으로 서버로 전송되어야하는 작은 용량의 데이터인 경우 사용
    ex) n일 동안 보지 않기, 비로그인시 장바구니 등

> 세션 스토리지

    탭을 종료했을 때 삭제되어도 괜찮은 데이터인 경우에 사용 가능
    ex) 이전 페이지나 이전 스크롤 위치 저장 등

> 로컬 스토리지

    브라우저를 종료했을 때도 유지되어야 할 때 사용
    ex) 사용자 설정 저장, 글 임시 저장 등

<br/>

# 쿠키 & 웹 스토리지의 보안 문제 해결 방안

> 쿠키 XSS : `HttpOnly 옵션` 적용해 해결

- httpOnly 옵션 : 서버에서 클라이언트로 정보를 보낼 때 스토리지에 저장된 정보를 함부로 접근할 수 없게 만드는 옵션
- HttpOnly 적용시 자바스크립트로 쿠키에 접근할 수 없게 된다

> 쿠키 CSRF : 쿠키 `SameSite`를 적용하거나 Referer 검증을 통해 대부분 해결 가능

- SameSite : 같은 도메인에서 요청이 아닌 경우에는 쿠키를 전송 하지 않는 것입니다.
  즉, 악의적인 사이트에서 시작되는 공격이 통하지 않습니다.
- SameSite - Strict & Lax 옵션이 존재
  1. Strict : 다른 도메인에서 들어온 모든 요청에대해 쿠키를 전송 하지 않는 것
  2. Lax : a 태그와 같은 링크를 클릭해서 접속하는 안전한 GET 요청인 경우에만 쿠키를 전송하는 것
  - Chrome은 기본적으로 Lax 옥션이 설정 되어 CSRF에 어느 정도 대처가 되어 있다.

<br/>

> 웹 스토리지 XSS 방어 : `innerHTML 사용하지 않는 것`

- 사용자의 입력이 자바스크립트 코드로 실행될 수 있는 코드를 작성하지 않는 것 (eval, document.write 등)
- innerHTML을 사용시 공격이 가능한 script 태그나 image 태그와 같은 각종 태그를 삽입할 수 있는 공격으로부터 예방
  - 사용해야할 경우 : XSS 보안 라이브러리 sanitize-html or DOMPurify 사용 추천

> HTTPS 사용 : SSL과 TLS1.3를 통한 가성비 좋은 보안 방법 활용

<br/>

# 세션

1. 로그인 요청 바탕으로 DB까지 검증이 완료되면
2. 인증된 사용자의 식별자 & 랜덤한 문자열로 세션 ID를 만들어 응답헤더에 전송

<br/>

> 장점 :

- 클라이언트가 저장을 할 수 있도록 하여 데이터 노출의 위험 적어
- 세션의 만료기간을 정해 탈취되어도 유효하지 않게된다
- 탈취된 세션을 서버에서 사제하면 세션 자체를 이용하지 못하게 되는 보안상 이점

> 문제점 : 서버를 여러 개 두었을 때의 로드밸런서 발생

- 서버 하나하나 자체에서 세션을 관리하고 있어서 생긴 문제
- 유저가 다음 인증이 필요한 요청을 할 경우 로드밸런서가 저장된 서버가 아닌 다른 서버로 요청을 전달할 경우 문제가 발생한다.
- 세션 하이재킹 공격 - 탈취해도 정보를 읽지 못하도록 암호화하거나 세션에 유효시간을 부여하는 방식으로 해결

> 해결 : 세션스토리지 활용 \_

- 서버들의 모든 세션을 한 곳에 관리하여 로드밸런서가 요청을 해도 한곳으로 조회가 요청되기 때문에 문제를 피할 수 있다

<br/>

# 세션 스토리지

> 인증 과정

1. 로그인 요청을 보내면 DB가 체킹
2. 한 번 인증을 해서 세션을 받고
3. 다음 요청부터는 세션스토리지랑 연결해 요청 진행 = DB까지 갈 필요없이

> 문제점 : 클라이언트가 많아질 경우에 저장소가 터진다

> 해결 : 정보 요청과 응답안에 우리 사용자의 상태를 담아 토큰을 활용한 인증과 인가 수행

<br/>

# JWT

1. 로그인 요청을 보내면 서버는 그에 따라 시크릿키를 통해서 토큰 생성
   - Set-Cookie : access = safe.payload.amv
   - 액세스 & 리프레시 토큰을 한 번에 만들어내 리프레시 토큰만 따로 저장소에 저장
2. 두 토큰을 한번에 응답 헤더에 넣어 전송하면 다음부터 액세스토큰을 HTTP 헤더에 실어 요청과 응답 진행
3. 서버는 본인이 가진 시크릿키로 토큰의 유효성 검사 진행
4. 유효하지 않다면 버리고 유효하다면 다음 단계인 사용자 정보를 파악

   ```
   사용자 정보중에 이름으로 어떤 유저인지 찾아내고
   만료시기를 통해 유효한 토큰인지, 권한 등을 확인할 수 있게 된다
   시크릿키를 통해서 유효성 검사를 통과한 토큰은 인증을 받은 토큰을 의미
   ```

> 구성

- Header : 암호화할 방식(alg), 타입(Type) 등을 포함
- Payload : 서버에서 보낼 데이터 - 일반적으로 user의 id, 유효기간 포함
- Verify Signature : Base64 방식으로 인코딩한 Header, Payload, Secret key 를 더한 후 서명된다

- 데이터 자체는 해독하기가 무척 쉬워 JWT 내에는 민감한 정보(비밀번호)를 대부분 담지 않는다
- 시크릿 키가 중요한 만큼 노출되면 JWT 토큰 탈취되기 때문에 시크릿 키를 서버 내부에 잘 관리해야 한다

> 장점 :

- 토큰으로 상태 관리하여 별도의 세션을 두지 않아도 된다
- 효율성 & DB 엑세스 하지 않아 속도가 빠르다는 장점
- 로드밸런서가 각자 자신이 가진 시크릿 키로 해독을 통해 인증을 진행하여 요청을 반환
- 서버가 계속적으로 확장되어도 똑같이 해독을 진행하여 인증 수행 가능

> 단점 :

- 해킹을 통해 액세스토큰이 탈취 당할 경우 사용자 자원에 접근 가능하여 보안에 꾸준히 신경써야한다

> 해결 : refresh 토큰 개념(만료기한) 도입

- 만료되었을 경우 브라우저에서 자동으로 액세스토큰과 리프레시 토큰을 함께 다시 서버로 보내
- 서버는 돌아온 리프레시 토큰을 참고해서 DB를 확인
- 새로 갱신한 액세스 토큰을 보내면 클라이언트에서 업데이트 된 액세스 토큰을 사용 가능

<br/>

# Oauth

```
다른 웹사이트에서 사용자 정보에 대한 접근 가능한 권한을 부여하는 수단
타 사이트를 활용한 로그인 방식에서 사용하는 인증절차가 'OAuth'
```

> 인증 방식

1. Oauth를 통해 제3의 서비스가 아이디 비밀번호 대신 access토큰을 발급해
2. access를 통해 제3의 서비스에 접근해 필요한 기능만 부분적으로 허용하도록

> 장점 :

- 회원들의 id/pw 처음부터 보관하지 않고 회원을 식별할 수 있는 기능 구현
- ex) 로그인 기능 : headerwirteip 기능의 기반 기술 = Oauth

<br/>

### 정리

- 보안이 중요한 은행 같은 서비스는 액세스 & 리프레시 토큰 만료기간을 짧게 잡아 보안에 치중
- 보통 일반사용자들이 사용하는 서비스는 길게 잡아서 사용자의 편의성을 높이는 방식으로 설계
- 프로그래밍에 정답이 없고, 주어진 요구사항에 맞춰서 구현하는 것이 최적
