## 모듈 번들러

- 모듈<br/>

  - 특정 기능을 갖는 분리된 작은 코드의 조각으로 시스템을 이루는 논리적인 부분

- 자바스크립트에서 정식 모듈 시스템인 ES Module이 도입되고 모듈을 사용할 수 있게 되었지만
  모든 파일을 네트워크 통신을 통해 가져와야 한다는 문제가 발생했다.
- 추가적으로 css , 이미지 파일도 네트워크 통신을 통해 가져와야 되기 때문에 모듈 번들러가 필요해졌다.

- 모듈 번들러는 말 그대로 여러 모듈을 모아 번들링 함으로써 이러한 문제를 해결할 수 있다.
- 모듈 번들러에서 모듈은 웹 애플리케이션을 구성하는 모든 자원을 의미 (HTML, CSS, Javascript, Images, Font 등 이 될수 있겠고 이 파일 하나하나가 모두 모듈)
- 번들러 : 프로그래밍적으로 접근하자면 필요한 의존성에 대해 추적하여 해당하는 의존성들을 그룹핑 해주는 도구
- 웹 애플리케이션을 구성하는 자원(HTML, CSS, Javscript, Images 등)을 모두 각각의 모듈로 보고 이를 조합해서 병합된 하나의 결과물을 만드는 도구
- ❗빌드 = 번들링 = 변환

웹 애플리케이션을 동작시키기 위한 서로 연관 관계가 있는 웹 구성 자원 (HTML, CSS, Javscript, Images 등)을 모두 각각의 모듈로 보고 이들의 의존성을 묶고 조합해서 합쳐진 하나의 결과물 (static한 자원)을 만드는 도구

모듈 번들링은 여러가지 웹 어플리케이션에 필요한 파일들의 의존성을 한데 묶고 조합하여 압축, 축소하여 static한 자원으로 뱉어내는 것이다.

### 역할

- 모듈을 읽어 브라우저에서 인식가능한 일반적인 함수로 변환
  - ex) ES Module을 CommonJS로 변환하는 도구 그대로 사용 가능
- 브라우저에서 모듈을 사용하기 위해 모듈의 의존 관계를 미리 분석하여 브라우저가 인식할 수 있는 자바스크립트 코드로의 변환 작업 수행
- 웹 애플리 케이션을 구성하는 몇십, 몇백개의 자원들을 하나의 파일로 병합 및 압축 해주는 동작을 모듈 번들링
- 애플리케이션에 필요한 모든 종류의 파일들을 모듈 단위로 나누어 최소한의 파일 묶음(번들)으로 만들어 낸다

### 번들러 사용의 장점

1. <b>네트워크 병목 현상 해결</b> \_ 여러 파일을 최적화 해서 하나의 파일로 묶기 때문에 주고 받는 파일의 크기를 줄여줆

2. <b>모듈 단위 코딩</b> \_ 유지 보수가 편함, 코드의 가독성 향상

3. <b>다양한 서드파티 기능 이용</b>
   - Webpack의 경우 Babel-loader과 같은 다양한 로더를 이용해서 모던 자바스크립트나 SASS를 사용할 수 있다.

### 모듈 번들러의 종류

- Webpack
- Parcel
- Rollup
- Browserify

<br/>

# 웹팩

```
웹팩에서는 모든 파일(자바스크립트,css, 이미지, 폰트 파일 등)을 모듈 보며 서로 의존성을 가진 여러 모듈을 돌며 하나의 파일로 묶는다. CRA로 React를 설치하면 웹팩이 자동 설정된다.
```

- 웹팩을 사용하기 위해 필요한 3가지 필수 설정

      --mode , --entry, --output

  - mode는 개발 / 프로덕션 같은 모드
  - entry는 모듈이 시작되는 부분 ( 일반적으로 index.js가 enrty가 된다 )
  - output는 번들링된 파일들을 저장할 위치를 나타낸다. ( 일반적으로 dist나 build라는 이름의 폴더를 사용한다. )

- 동작 방식
  modules라는 자바스크립트 객체에 개별 함수들을 넣어주고 함수들을 넣어줌으로써 wrapping 되며 webpackStart로 모든 모듈들을 접합시켜준다. Webpack의 경우 config파일 없이 가능하지만 옵션(babel, SCSS 등) 사용하고자 할 때 config 설정이 필요하다. 일반적으로 많은 설정이 필요하며 이를 구성하는데 많은 시간을 필요하지만 WebPack 4 부터는 Parcel과 동일하게 따로 설정없이 적용 가능하다!

### ✓ 로더(Loader)

- 웹팩이 자바 스크립트 파일이 아닌 웹 자원(html, css, 이미지, 폰트 등)을 변환할 수 있도록 도와주는 도구

- 자주 사용하는 로더<br/>
  ```
  자바스크립트에서 css 파일을 모듈로서 가져올 수 있게 해주는 css-loader
  자바스크립트로 들어간지 css를 html 에 넣어서 브라우저 렌더링 시 적용될 수 있게 해 주는 style-loader
  babel-loader는 모듈을 입력받아 원하는 형태로 변환한 후 새로운 모듈을 출력
  이미지를 모듈로 사용할 수 있게 해주는 file-loader 등
  ```

### ✓ 플러그인

- 번들된 결과물의 형태를 바꾸는 일 즉 후처리를 하는 역할
- 난독화나 특정 문자열 치환 등의 처리를 할 수 있다.

- 플러그인의 예
  ```
  - DefinePlugin :
  개발용 api와 배포 api 주소를 서로 다르게 설정 하는 것 같이 환경 의존적인 정보를 관리에 사용
  ```

### ✓ 바벨 (트랜스파일러)

- 바벨은 서로 다른 브라우저 스펙으로 인해 하나의 프로젝트 코드로 모든 브라우저로 커버 하지 못하게 되는 크로스브라우징 문제를 해결한다.
- 최신 스펙을 사용하여 코드를 작성하여도 바벨은 브라우저 마다 동일하게 동작할 수 있는 코드로 변환 시킨다.

  - Ts, jsx로 작성된 코드도 변환할 수 있다

  ```
  JSX
  -> React.createElement("h1", null, "\uBC14\uBCA8")
  ```

    <br/>

- 코드 변환 3단계에 걸쳐 이루어진다.
  ```
  1. 먼저 코드를 각 토큰으로 분해하고
  2. ES5 스펙으로 변환한 뒤
  3. 변환된 코드를 출력하는 방식
  ```

# rollup.js

- 웹팩과 같은 모듈 번들러로 common.js나 AMD가 아닌 ESModule를 사용한다는 것이 특징이다.
- 쓰이지 않는 스크립트를 추려내서 더 적은 크기로 만드는 Tree-Shaking 도입
- common.js인 module.exports로 설정 파일을 작성하는 웹팩과 달리 `export / import` 로 설정 파일을 작성한다.

# parcel

- 웹팩의 config가 불편하다면 no-config컨셉의 번들러을 사용
- config 파일 설정 없이 CSS, SCSS, Images, Babel, PostCSS, PostHTML, TypeScript 등을 지원한다.
- 즉 설정이 필요없는 zero-configuration으로, 빠르게 적용이 가능하다라는 큰 장점을 가진다.

> 동작 과정

Webpack 과 달리 JavaScript 엔트리포인트를 지정해주는 것이 아니라, 애플리케이션 진입을 위한 HTML파일 자체를 읽어나가면서 JavaScript, CSS, 이미지 에셋 등을 직접 참조한다.

<br/>

## snowpack

- 모듈 번들러가 아닌 빌드 도구
- 빠른 빌드 속도가 특징
- go로 만들어진 빌드 툴의 경우 웹팩에 비해 훨씬 빠른 속도를 제공한다.
- 장점

  ```
  ✓ 서비스를 개발하며 파일 수정 시 업데이트 사항을 반영해 브라우저에 결과를 확인할 경우가 많다.
  ✓ 한번에 전체를 번들링하는 것이 아니라 개발할때는 각 파일을 나눠서 빌드
  ✓ 한 글자를 수정해도 새롭게 번들을 만드는 웹팩과 달리,
  스노우팩은 번들과정이 없으며 캐시를 사용하여 변경되지 않는 파일은 다시 빌드 하지 않기 때문에 속도가 매우 빠르다.
  ```

- 이러한 방식이 가능해진 것은 브라우저가 ES모듈시스템을 지원하기 때문이다.
- 개발할때는 esbuild로, 프로덕션으로 내보낼때에만 webpack으로 새로 빌드하는 방식
- 만약 스노우 팩을 사용하여 번들링이 필요해진다면 웹팩이나 rollup.js를 추가로 사용할 수 있다.

<br/>

### 번들러 선택의 기준

- 많은 서드파티를 필요로 하는 복잡한 어플리케이션이라면 Webpack
- 최소한의 서드파티로 라이브러리를 만들고 싶다면 Rollup
- 복잡한 설정을 피하고 비교적 간단한 어플리케이션을 만들고 싶다면 Parcel
- javascript가 아닌 다른 언어를 이용해서 더 빠른 번들러를 만드는 방식이 존재한다.
  - 어차피 번들러

---

모듈의 과거

> 모듈을 위해 필요한 세가지 : 스코프 & 정의 & 사용

## common.js

    module.exports
    require('./file.js')∂

    module.exports 통해 모듈을 정의 & require 문법을 통해 정의된 모듈을 가져다 쓰는 방식

- 각각의 파일이 독립적인 스코프를 가지며 모든 파일이 로컬에 존재하여 바로 불러올 수 있음을 전제로, 동기적으로 동작한다는 특징을 가진다.
- nodejs 에서 사용

## AMD ( Asynchronous Module Definition )

- 비동기 상황에서도 모듈을 사용하기 위한 방법

```
define(id?, dependencies?, factory);
require([modulePath], function(module){
   // module을 활용하는 실제 코드
})
```

- define을 통해 모듈을 정의하고 id 에는 모듈을 식별할 때 사용할 인수를 작성,
  dependencies 에서는는 module의 의존성을 나타내는 배열을 & factory에는 모듈의 실제 구현 작성하면 된다.

- 브라우저 환경에서 자바스크립트는 파일 스코프가 따로 존재하지 않는데, AMD에서는 define함수가 파일 스코프의 역할을 대신한다.

- AMD API 명세로 고현된 대표적인 도구는 dojo toolkit & require.js 이다.

<br/>

## UMD ( Universal Module Definition )

- 서로 호환되지 않게 된 commans.js와 AMD를 모두 지원해야 하는 경우 사용
- 모듈 선언 스펙이라기보다 둘 모두를 지원하기 위한 디자인 패턴에 가깝다

## 2015 js 정식 모듈 시스템 도입

```
export default App;
--
import App from './App.js';
```
